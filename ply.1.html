<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>ply(1) - dynamically instrument the kernel</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
  <style type='text/css' media='all'>
  /* style: toc */
  .man-navigation {display:block !important;position:fixed;top:0;left:113ex;height:100%;width:100%;padding:48px 0 0 0;border-left:1px solid #dbdbdb;background:#eee}
  .man-navigation a,.man-navigation a:hover,.man-navigation a:link,.man-navigation a:visited {display:block;margin:0;padding:5px 2px 5px 30px;color:#999;text-decoration:none}
  .man-navigation a:hover {color:#111;text-decoration:underline}
  </style>
  <style type='text/css' media='all'>
  /* style: style */
  body,.mp {background-color: #fdf6e3;color: #839496}
  .mp h1,.mp h2,.mp h3,.mp h4 {color: #586e75}
  .mp code,.mp strong,.mp b {color: #586e75}
  .mp em,.mp var {color: #586e75}
  .mp pre code {color: #586e75}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color: #268bd2}
  .mp a:visited {color: #268bd2}
   
  .man-navigation {color: #93a1a1;border-left: 1px solid #93a1a1;background-color: #eee8d5}
  .mp .man-navigation a {color: #93a1a1}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#SYNOPSIS">SYNOPSIS</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#OPTIONS">OPTIONS</a>
    <a href="#SYNTAX">SYNTAX</a>
    <a href="#PROVIDERS">PROVIDERS</a>
    <a href="#EXAMPLE">EXAMPLE</a>
    <a href="#RETURN-VALUE">RETURN VALUE</a>
    <a href="#AUTHORS">AUTHORS</a>
    <a href="#COPYRIGHT">COPYRIGHT</a>
    <a href="#SEE-ALSO">SEE ALSO</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>ply(1)</li>
    <li class='tc'></li>
    <li class='tr'>ply(1)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>ply</code> - <span class="man-whatis">dynamically instrument the kernel</span>
</p>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<p><code>ply</code> <var>program-file</var> <br />
<code>ply</code> <var>program-text</var></p>

<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>ply dynamically instruments the running kernel to aggregate and
extract user-defined data. It compiles an input program to one or more
Linux <a class="man-ref" href="http://man7.org/linux/man-pages/man2/bpf.2.html">bpf<span class="s">(2)</span></a> binaries and attaches them to arbitrary points in the kernel
using kprobes and tracepoints.</p>

<h2 id="OPTIONS">OPTIONS</h2>

<dl>
<dt><code>-A</code>, <code>--ascii</code></dt><dd><p>Restrict output to ASCII, no Unicode runes.</p></dd>
<dt><code>-c</code> <var>command</var>, <code>--command</code>=<var>command</var></dt><dd><p>When all probes are running, run <var>command</var>. When the command
exits, stop all probes and exit. The command is run as if invoked
with <code>sh -c &lt;command></code>.</p></dd>
<dt><code>-d</code>, <code>--debug</code></dt><dd><p>Enable debugging output.</p></dd>
<dt><code>-e</code>, <code>--dry-run</code></dt><dd><p>Exit after compilation, without actually instrumenting the
system. Typically used in conjunction with <code>--dump</code>.</p></dd>
<dt><code>-h</code>, <code>--help</code></dt><dd><p>Print usage message.</p></dd>
<dt><code>-S</code>, <code>--dump</code></dt><dd><p>After compilation, dump the internal AST, generated BPF
instructions and other internal information. This is very useful
to include when reporting a bug.</p></dd>
<dt><code>-v</code>, <code>--version</code></dt><dd><p>Print version information.</p></dd>
</dl>


<h2 id="SYNTAX">SYNTAX</h2>

<p>The syntax is C-like in general, taking its inspiration <a class="man-ref" href="https://docs.oracle.com/cd/E23823_01/html/816-5166/dtrace-1m.html">dtrace<span class="s">(1)</span></a> and,
by extension, from <a class="man-ref" href="http://man7.org/linux/man-pages/man1/gawk.1.html">awk<span class="s">(1)</span></a>.</p>

<h3 id="Probes">Probes</h3>

<p>A program consists of one or more <em>probes</em>, which are analogous to
awk's pattern-action statements. The syntax for a probe is as follows:</p>

<pre><code>provider:probe-definition ['/' predicate '/']
{
     statement ';'
    [statement ';' ... ]
}
</code></pre>

<p>The <em>provider</em> selects which probe interface to use. See the PROVIDERS
section for more information about each provider. It is then up to the
provider to parse the <em>probe-definition</em> to determine the point(s) of
instrumentation.</p>

<p>When tracing, it is often desirable to filter events to match some
criteria. Because of this, ply allows you to provide a <em>predicate</em>,
i.e. an expression that must evaluate to a non-zero value in order for
the probe to be executed.</p>

<p>Then follows a block of <em>statements</em> that perform the actual information
gathering.</p>

<p>A provider may define a default probe clause to be used if the user
does not supply one.</p>

<h3 id="Control-of-Flow">Control of Flow</h3>

<p>Probes support basic conditional control of flow via an
<em>if-statement</em>, which conforms to the same rules as C's equivalent:</p>

<pre><code>'if' '(' expr ')'
    statement ';' | block
[else
    statement ';' | block]
</code></pre>

<p>In order to ensure that a probe will have a finite run-time the kernel
does not allow backwards branching. As a result, ply does not have any
loop construct like <em>for</em> or <em>while</em>. A simple <em>for</em> statement with an
invariant that is known at compile-time could be added later. In that
case we could unroll the loop when generating BPF.</p>

<h3 id="Type-System">Type System</h3>

<p>The type system is modeled after C. As such ply understands the
difference between signed and unsigned integers, the difference
between a short and a long long, what separates an integer from a
pointer, how a struct is laid out in memory and so on. It is not
complete though, notably floating point numbers and unions are
missing.</p>

<p>Programs are statically typed, but all types are inferred
automatically. Thus, the type system is mostly hidden from the
user. Plans are to expose more of it in the future by allowing casts,
type declarations and so on.</p>

<p>Numbers and string literals are specified in the same way as in
C.</p>

<h3 id="Maps">Maps</h3>

<p>The primary way to extract information is to store it in a <em>map</em>,
i.e. in a hash table. Like <a class="man-ref" href="http://man7.org/linux/man-pages/man1/gawk.1.html">awk<span class="s">(1)</span></a>, ply dynamically creates any
referenced maps and their key and value types are inferred from the
context in which they are used. All maps are in the global scope and
can thus be used both for extracting data to the end-user, and for
carrying data between probes. Map names follow the rules of
identifiers from C.</p>

<pre><code>mapname[exprs]
</code></pre>

<p>Data can be stored in a map by assigning a value to a given key:</p>

<pre><code>mapname[exprs] = expr
</code></pre>

<p>If a map key is assigned the special value <em>nil</em>, the key is deleted
and will return its zero value if referenced again.</p>

<h3 id="Aggregations">Aggregations</h3>

<p>More often than not, looking at each individual datum from a trace is
not nearly as helpful as an <em>aggregation</em> of the data. Therefore ply
supports aggregating data at the source, thereby reducing tracing
overhead. Aggregations are syntactically similar to maps, indeed they
are a kind of map, but they are distinguished by a leading '@'. Also,
they can only be assigned the result of one of the following
aggregation functions:</p>

<dl>
<dt><code>@agg[exprs] = count()</code></dt><dd><p>Bump a counter.</p></dd>
<dt><code>@agg[exprs] = quantize(scalar-expr)</code></dt><dd><p>Evaluates the argument and aggregates on the most significant bit
of the result. In other words, it stores the distribution of the
expression.</p></dd>
</dl>


<h2 id="PROVIDERS">PROVIDERS</h2>

<p>A <em>provider</em> makes data available to the user by exporting functions
and variables to the probe. Function calls use the same syntax as most
languages that inherit from C. In addition to the provider-specific
functions, all providers inherits a set of common functions and
variables:</p>

<ul>
<li><p><code>char[16] comm</code>, <code>char[16] execname</code>
<em>name</em> of the running process's executable.</p></li>
<li><p><code>u32 cpu</code>
<em>CPU ID</em> of the processor on which the probe fired.</p></li>
<li><p><code>u32 gid</code>
<em>Group ID</em> of the running process.</p></li>
<li><p><code>u32 kpid</code>:
<em>Kernel PID</em> of the running process. Also known as <em>pid</em> by the
kernel. For a single-threaded process <em>kpid</em> is equal to
<em>pid</em>. For multi-threaded processes, <em>kpid</em> will be unique while
<em>pid</em> will be the same across all threads.</p></li>
<li><p><code>char[N] mem(void *address [, int size])</code>
Copy <em>size</em> bytes from <em>address</em>. If <em>size</em> is omitted, 64 bytes
will be copied.</p></li>
<li><p><code>s64 time</code>, <code>s64 walltime</code>:
Nanoseconds elaped since system boot. <em>time</em> is intended for time
deltas and <em>walltime</em> should be used for timestamps. They refer to
the same data, but with different default output formats.</p></li>
<li><p><code>u32 pid</code>:
<em>Process ID</em> of the running process. Also known as <em>thread group
ID</em> (tgid) by the kernel.</p></li>
<li><p><code>void print(...)</code>:
<em>Print</em> each expression with its default output format, separated
by commas and terminated with a newline, to ply's standard out.</p></li>
<li><p><code>void printf(format, ...)</code>:
Prints <em>formatted output</em> to ply's standard out. In addition to
the formats recognized by the printf sitting in your &lt;stdio.h>,
ply's also recognizes '%v' which will dump the value according to
the inferred type's default (i.e. how <em>print</em> would print it).</p></li>
<li><p><code>int strcmp(char *a, char *b)</code>:
Returns -1, 0 or 1 if the first argument is less than, equal to or
greater than the second argument respectively. Strings are
compared by their lexicographical order.</p></li>
<li><p><code>u32 uid</code>:
<em>User ID</em> of the running process.</p></li>
</ul>


<h3 id="kprobe-and-kretprobe">kprobe and kretprobe</h3>

<p>These providers use the corresponding kernel features to instrument
arbitrary instructions in the kernel. The <em>probe-definition</em> may be
either an address or a symbol name. When using a symbol name, glob
expansion is performed allowing a single probe to be inserted at
multiple locations. An offset relative to a symbol may also be
specfied for kprobes.</p>

<p>Examples:</p>

<ul>
<li><em>kretprobe:schedule</em>: Trace every time <code>schedule</code> returns.</li>
<li><em>kprobe:SyS_*</em>: Trace every time a syscall is made.</li>
<li><em>kprobe:dev_hard_start_xmit+8</em>: Trace function with offset.</li>
</ul>


<p>Shared variables:</p>

<dl>
<dt><code>struct pt_regs *regs</code></dt><dd><p>Hardware register contents from when the probe was triggered. This
matches the definition in &lt;sys/ptrace.h> on your system.</p></dd>
<dt><code>u32 stack</code></dt><dd><p><em>Stack trace ID</em> of the current probe. This is just returns an
index into a separate map containing the actual instruction
pointers. As a user though, you can think of this function as
returning a string containing the stack trace at the current
location. Indeed <em>print(stack)</em> will produce exactly that.</p>

<p>CAUTION: On some architectures (looking at you, ARM), capturing
stack traces at the entry of a function, before the prologue has
run, does not work. Setting your probe after the prologue will
work around the issue (typically two instructions, or +8, on ARM).</p></dd>
</dl>


<p><em>kprobe</em> specific functions:</p>

<dl>
<dt><code>arg0</code>, <code>arg1</code> ... <code>argN</code>:</dt><dd><p></p>

<p>Returns the value of the specified <em>argument</em> of the function to
which the probe was attached, zero-indexed. I.e. arg0 is the 1st
argument, arg1 is the 2nd, and so on.</p>

<p>CAUTION: ply simply maps registers to arguments according to the
syscall ABI. If your compiler decides to optimize out arguments or
do other sneaky things, ply will be utterly oblivious to that.</p></dd>
<dt><code>void *caller</code></dt><dd><p>The program counter, as recorded in <code>regs</code>, at the time the probe
was triggered.  was attached. The default output format will
resolve it to a symbolic name if one is available.</p></dd>
</dl>


<p><em>kretprobe</em> specific function:</p>

<dl>
<dt class="flush"><code>retval</code></dt><dd>Return value of the probed function.</dd>
</dl>


<h2 id="EXAMPLE">EXAMPLE</h2>

<h3 id="Extracting-data">Extracting data</h3>

<p>Print all <code>openat</code>ed files on the system, and who opened them:</p>

<pre><code>kprobe:SyS_openat
{
    print(comm, pid, str(arg1));
}
</code></pre>

<h3 id="Quantize">Quantize</h3>

<p>Record the distribution of the return value of <span class="man-ref">read<span class="s">(2)</span></span>:</p>

<pre><code>kretprobe:SyS_read
{
    @["dist"] = quantize(retval);
}
</code></pre>

<h3 id="Wildcards">Wildcards</h3>

<p>Count all syscalls made on the system, grouped by function:</p>

<pre><code>kprobe:SyS_*
{
    @[caller] = count();
}
</code></pre>

<p>Count all syscalls made by every <span class="man-ref">dd<span class="s">(1)</span></span> process, grouped by function:</p>

<pre><code>kprobe:SyS_* / !strcmp(execname, "dd") /
{
    @[caller] = count();
}
</code></pre>

<h3 id="Object-Tracking">Object Tracking</h3>

<p>Record the distribution of the time it takes an <em>skb</em> to go from
<em>netif_receive</em> to <em>ip_rcv</em>:</p>

<pre><code>kprobe:__netif_receive_skb_core
{
    rx[arg0] = time;
}

kprobe:ip_rcv / rx[arg0] /
{
    @["diff"] = quantize(time - rx[arg0]);
}
</code></pre>

<h2 id="RETURN-VALUE">RETURN VALUE</h2>

<dl>
<dt class="flush"><code>0</code></dt><dd><p>Program was successfully compiled and loaded into the kernel.</p></dd>
<dt><code>Non-Zero</code></dt><dd><p>An error occurred during compilation or during kernel setup.</p></dd>
</dl>


<h2 id="AUTHORS">AUTHORS</h2>

<p>Tobias Waldekranz <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#x3a;&#116;&#x6f;&#x62;&#105;&#x61;&#115;&#64;&#x77;&#x61;&#108;&#x64;&#x65;&#107;&#114;&#97;&#x6e;&#122;&#46;&#x63;&#x6f;&#109;" data-bare-link="true">&#x74;&#111;&#x62;&#105;&#x61;&#115;&#x40;&#x77;&#x61;&#x6c;&#100;&#101;&#107;&#114;&#97;&#110;&#122;&#x2e;&#x63;&#111;&#109;</a></p>

<h2 id="COPYRIGHT">COPYRIGHT</h2>

<p>Copyright 2018 Tobias Waldekranz</p>

<p>License: GPLv2</p>

<h2 id="SEE-ALSO">SEE ALSO</h2>

<p><a class="man-ref" href="http://man7.org/linux/man-pages/man1/gawk.1.html">awk<span class="s">(1)</span></a> <a class="man-ref" href="https://docs.oracle.com/cd/E23823_01/html/816-5166/dtrace-1m.html">dtrace<span class="s">(1)</span></a> <a class="man-ref" href="http://man7.org/linux/man-pages/man2/bpf.2.html">bpf<span class="s">(2)</span></a></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'></li>
    <li class='tc'>October 2018</li>
    <li class='tr'>ply(1)</li>
  </ol>

  </div>
</body>
</html>
