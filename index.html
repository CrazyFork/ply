<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>ply</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.6/css/bootstrap.min.css" integrity="sha384-rwoIResjU2yc3z8GV/NPeZWAv56rSmLldC3R/AZzGRnGxQQKnKkoFVhFQhNUwEyJ" crossorigin="anonymous">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono:100,400,400i,700">

    <link rel="stylesheet" href="css/style.css">
</head>

<body>
  <div class="jumbotron d-flex align-items-end">
    <div class="container">
      <div class="row d-flex align-items-end">

	<div class="col-md-6">
	  <h1>ply</h1>
	  <p>/* a dynamic tracer for Linux */</p>
	</div>

	<div class="col-md-3 d-flex justify-content-end">
	  <p><a href="ply.1.html">[read the manual]</a></p>
	</div>

	<div class="col-md-3 d-flex justify-content-end">
	  <p><a href="https://github.com/iovisor/ply">[fork on github]</a></p>
	</div>

      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-md-4">
        <h3>$_ flexible</h2>
        <p class="text-justify">
	  Type inference in combination with a compact C-like syntax
	  means scripts can be written and edited in seconds, directly
	  in your favorite shell. The language is heavily inspired by,
	  though not nearly as powerful as, awk(1) and dtrace(1).
	</p>
      </div>
      <div class="col-md-4">
        <h3>&gt;&lt; small</h2>
        <p class="text-justify">
	  Designed with embedded systems in mind. Written in C, all
	  ply needs to run is libc and a modern kernel with Linux BPF
	  support. No external kernel modules, no LLVM, no
	  python. Works on aarch64, arm, powerpc, and x86_64 today &mdash;
	  adding an ISA is easy.
	</p>
      </div>
      <div class="col-md-4">
        <h3>&lt;3 efficient</h2>
        <p class="text-justify">
	  Data gathering and aggregation is done in the kernel using
	  Linux BPF programs that are JIT compiled to native
	  instructions on most common architectures. Thus, ply runs
	  with very low overhead, allowing it to probe even the
	  hottest code paths.
	</p>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <p>&nbsp;"yeah yeah whatever, so what can I actually do with it?!"</p>
      <p>- well I'm glad you asked, dear reader, here are a few examples</p>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-md-10">
	<h4>count syscalls, system-wide</h4>
      </div>
    </div>
    <div class="row text-justify">
      <div class="col-md-5">
	<pre>#!/usr/bin/env ply

kprobe:SyS_*
{
    @syscalls[caller] = count();
}</pre>
        <p>
	  This probe will be attached to all functions whose name
	  starts with <code>SyS_</code>, i.e. all syscalls. On each
	  syscall, the probe will fire and index into the user-defined
	  aggregation <code>@syscalls</code> using the program counter
	  <code>caller</code> as the key and bump a counter.
	</p>
	<p>
	  ply will compile the script, attach it to the matching
	  probes and start collecting data. On exit, ply will dump the
	  values of all user-defined maps and aggregations.
	</p>
      </div>
      <div class="col-md-5">
	<pre>~$ ply count-syscalls.ply
ply: active
^Cply: deactivating

@syscalls:
{ sys_sigaltstack+1 }: 1
{ sys_set_tid_address+1 }: 2
{ sys_sysinfo+1 }: 2
{ sys_alarm+1 }: 2
{ sys_mincore+1 }: 2
{ sys_pread64+1 }: 2
{ sys_newlstat+1 }: 2
{ sys_unlink+1 }: 2
[REDACTED LINES]
{ sys_newfstat+1 }: 586
{ sys_mmap_pgoff+1 }: 599
{ sys_mmap+1 }: 600
{ sys_rt_sigprocmask+1 }: 859
{ sys_close+1 }: 863
{ sys_ppoll+1 }: 1315
{ sys_epoll_wait+1 }: 1731
{ sys_poll+1 }: 2644
{ sys_write+1 }: 3262
{ sys_recvmsg+1 }: 3624
{ sys_ioctl+1 }: 4423
{ sys_read+1 }: 5059
{ sys_futex+1 }: 7918</pre>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-md-10 offset-md-2">
	<h4>read(2) return distribution</h4>
      </div>
    </div>
    <div class="row text-justify">
      <div class="col-md-5 offset-md-2">
	<pre>#!/usr/bin/env ply

kretprobe:SyS_read
{
    @["retsize"] = quantize(retval);
}</pre>
        <p>
	  This example shows a very simple script that instruments the
	  return of the <code>read(2)</code> syscall and records the
	  distribution of the return argument.
	</p>
	<p>
	  User-defined aggregations in ply always start
	  with <code>@</code>.  When writing small scripts, only using
	  one aggregation, it is common and convenient to simply call
	  it <code>@</code>.
	</p>
      </div>
      <div class="col-md-5">
	<pre>~$ sudo ./read-dist.ply
ply: active
^Cply: deactivating

@:
{ retsize }: 
	         < 0	     861 ┤████████▏                       │
	[   0,    1]	     865 ┤████████▏                       │
	[   2,    3]	     372 ┤███▌                            │
	[   4,    7]	       1 ┤                                │
	[   8,   15]	    1090 ┤██████████▎                     │
	[  16,   31]	     122 ┤█▏                              │
	[  32,   63]	      22 ┤▎                               │
	[  64,  127]	      25 ┤▎                               │
	[ 128,  255]	       1 ┤                                │
	...
	[ 512,   1k)	      23 ┤▎                               │
	[  1k,   2k)	       5 ┤                                │
	...
	[  4k,   8k)	       2 ┤                                │
	...
	[ 16k,  32k)	      11 ┤▏                               │
</pre>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-md-10">
	<h4>capture stack traces</h4>
      </div>
    </div>
    <div class="row text-justify">
      <div class="col-md-5">
	<pre>#!/usr/bin/env ply

kprobe:i2c_transfer
{
    print(stack);
}</pre>
        <p>
	  Sometimes it can be useful to know how a particular location
	  is reached. <code>kprobes</code> can get the current stack
	  trace via the <code>stack</code> variable.
	</p>
	<p>
	  In this example, the stack trace is simply printed to
	  <code>stdout</code>, but it can also be used as a map key in
	  an aggregation. I.e. it is possible to do frequency counting
	  based on how a function was reached.
	</p>
      </div>
      <div class="col-md-5">
	<pre>root@chaos:~ $ ply ./i2c-stack.ply &
root@chaos:~ $ ply: active

root@chaos:~ $ hwclock -r

    i2c_transfer
    i2c_smbus_read_i2c_block_data+0x58
    ds1307_native_smbus_read_block_data+0x88
    ds1307_get_time+0x38
    __rtc_read_time+0x54
    rtc_read_time+0x3c
    rtc_dev_ioctl+0x318
    do_vfs_ioctl+0xa0
    sys_ioctl+0x44
    __sys_trace_return
Mon Feb 20 18:33:33 2017  0.000000 seconds
root@chaos:~ $ fg
ply ./i2c_stack.ply
^Cply: deactivating
root@chaos:~ $</pre>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="row">
      <div class="col-md-10 offset-md-2">
	<h4>opensnoop</h4>
      </div>
    </div>
    <div class="row text-justify">
      <div class="col-md-5 offset-md-2">
	<pre>#!/usr/bin/env ply

kprobe:do_sys_open
{
    printf("%v(%v): %s\n",
           comm, pid, str(arg1));
}</pre>
        <p>
	  Every time a process calls <code>open(2)</code> print the calling process's
	  <code>comm</code>, i.e. executable name, PID and the
	  filename by extracting a 128-byte string from the address of
	  the first argument using the <code>str()</code> function.
	</p>
      </div>
      <div class="col-md-5">
	<pre>~$ sudo ./opensoop.ply
ply: active
ply             (28836): /sys/kernel/debug/tracing/events/enable
SimpleCacheWork ( 5818): /home/wkz/.cache/google-chrome/Default/Cache/37586f4b9464a393_0
irqbalance      ( 1083): /proc/interrupts
irqbalance      ( 1083): /proc/stat
irqbalance      ( 1083): /proc/irq/18/smp_affinity
irqbalance      ( 1083): /proc/irq/126/smp_affinity
irqbalance      ( 1083): /proc/irq/128/smp_affinity
irqbalance      ( 1083): /proc/irq/122/smp_affinity
irqbalance      ( 1083): /proc/irq/11/smp_affinity
irqbalance      ( 1083): /proc/irq/124/smp_affinity
irqbalance      ( 1083): /proc/irq/16/smp_affinity
irqbalance      ( 1083): /proc/irq/1/smp_affinity
irqbalance      ( 1083): /proc/irq/8/smp_affinity
irqbalance      ( 1083): /proc/irq/9/smp_affinity
irqbalance      ( 1083): /proc/irq/12/smp_affinity
irqbalance      ( 1083): /proc/irq/120/smp_affinity
irqbalance      ( 1083): /proc/irq/121/smp_affinity
Chrome_IOThread ( 5361): /dev/shm/.org.chromium.Chromium.59XkZF
SimpleCacheWork ( 5818): /home/wkz/.cache/google-chrome/Default/Cache/37586f4b9464a393_0
Core Thread     ( 5368): /home/wkz/.config/spotify/Users/wkz-user/pending-messages.tmp
Core Thread     ( 5368): /home/wkz/.config/spotify/Users/wkz-user/pending-messages.tmp
^Cply: deactivating</pre>
      </div>
    </div>
  </div>

  <div class="header">
    <div class="container">
      <footer>
	<p>
	  &copy; 2017 Tobias Waldekranz
	</p>
      </footer>
    </div>
  </div>

</body>

</html>
